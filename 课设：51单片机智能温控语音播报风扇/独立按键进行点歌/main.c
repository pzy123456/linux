/**************************************************************************************
*		              独立按键实验												  *
实现现象：下载程序后按下K1按键可以播放02文件夹下的001，按k2按键可以播放02的002
注意事项：无																				  
***************************************************************************************/

#include "reg52.h"			 //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16;	  //对数据类型进行声明定义
typedef unsigned char u8;

sbit k1=P3^2;	 //定义P31口是k1
sbit k2=P3^3;	 //定义P30口是k2

void UsartInit();
void Uart_PutByte(u8 ch);
void Uart_SendCMD(u8 CMD ,u8 feedback , u16 dat);
void DoSum( u8 *Str, u8 len);
u8 Send_buf[10] = {0};
/*******************************************************************************
* 函 数 名         : delay
* 函数功能		     : 延时函数，i=1时，大约延时10us
*******************************************************************************/
void delay(u16 i)
{
	while(i--);	
}

/*******************************************************************************
* 函 数 名         : keypros
* 函数功能		   : 按键处理函数，判断按键K1是否按下
*******************************************************************************/
void keypros()
{
	if(k1==0)		  //检测按键K1是否按下
	{	
		delay(3000);   //消除抖动 一般大约10ms
		if(k1==0)	 //再次判断按键是否按下
		{
			Uart_SendCMD(0x0f , 0 , 0x0201) ;
		}
		while(!k1);	 //检测按键是否松开
	}		
	if(k2==0)		  //检测按键K1是否按下
	{	
		delay(3000);   //消除抖动 一般大约10ms
		if(k2==0)	 //再次判断按键是否按下
		{
			Uart_SendCMD(0x0f , 0 , 0x0202) ;
		}
		while(!k2);	 //检测按键是否松开
	}

	
}

/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{	
	
	while(1)
	{	
		UsartInit();
		keypros();  //按键处理函数	
	}		
}
/*******************************************************************************
* 函数名         :UsartInit()
* 函数功能		   :设置串口
* 输入           : 无
* 输出         	 : 无
*******************************************************************************/
void UsartInit()
{
	SCON=0X50;			//设置为工作方式1
	TMOD=0X20;			//设置计数器工作方式2
	PCON=0X00;			//波特率不加倍
	TH1=0XFD;				//计数器初始值设置，注意波特率是9600的
	TL1=0XFD;
	ES=1;						//打开接收中断
	REN = 1;				//串口使能
	TR1=1;					//打开计数器
}
/********************************************************************************************
 - 功能描述： 串口发送一个字节
 - 隶属模块： 外部
 - 参数说明：
 - 返回说明：
 - 注：	      
********************************************************************************************/
void Uart_PutByte(u8 ch)
{
    SBUF  = ch;
    while(!TI){;}
    TI = 0;
}
/*****************************************************************************************************
 - 功能描述： 串口发送一帧数据
 - 隶属模块： 内部 
 - 参数说明： 
 - 返回说明： 
 - 注：无     
*****************************************************************************************************/
void SendCmd(u8 len)
{
    u8 i = 0 ;

    Uart_PutByte(0x7E); //起始
    for(i=0; i<len; i++)//数据
    {
		Uart_PutByte(Send_buf[i]) ;
    }
    Uart_PutByte(0xEF) ;//结束
}

/********************************************************************************************
 - 功能描述：求和校验
 - 隶属模块：
 - 参数说明：
 - 返回说明：
 - 注：      和校验的思路如下
             发送的指令，去掉起始和结束。将中间的6个字节进行累加，最后取反码
             接收端就将接收到的一帧数据，去掉起始和结束。将中间的数据累加，再加上接收到的校验
             字节。刚好为0.这样就代表接收到的数据完全正确。
********************************************************************************************/
void DoSum( u8 *Str, u8 len)
{
    u16 xorsum = 0;
    u8 i;

    for(i=0; i<len; i++)
    {
        xorsum  = xorsum + Str[i];
    }
	xorsum     = 0 -xorsum;
	*(Str+i)   = (u8)(xorsum >>8);
	*(Str+i+1) = (u8)(xorsum & 0x00ff);
}


/********************************************************************************************
 - 功能描述： 串口向外发送命令[包括控制和查询]
 - 隶属模块： 外部
 - 参数说明： CMD:表示控制指令，请查阅指令表，还包括查询的相关指令
              feedback:是否需要应答[0:不需要应答，1:需要应答]
              data:传送的参数
 - 返回说明：
 - 注：       
********************************************************************************************/
void Uart_SendCMD(u8 CMD ,u8 feedback , u16 dat)
{
    Send_buf[0] = 0xff;    //保留字节 
    Send_buf[1] = 0x06;    //长度
    Send_buf[2] = CMD;     //控制指令
    Send_buf[3] = feedback;//是否需要反馈
    Send_buf[4] = (u8)(dat >> 8);//datah
    Send_buf[5] = (u8)(dat);     //datal
    DoSum(&Send_buf[0],6);        //校验
    SendCmd(8);       //发送此帧数据
}
